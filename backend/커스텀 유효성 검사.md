> 그냥 유효성 검사와 다른점은 조금 더 친절하게 에러 메시지를 꾸밀 수 있고 다양한 방식으로 표현할 수 있다는 장점이 있다.

예시 코드를 봐보자

기존에는

```java
package com.example.boardcrud.dto.Request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PostRequest {

    @NotBlank(message = "제목은 비워둘수 없습니다.")
    @Size(max = 100, message = "제목은 100자까지만 가능합니다")
    private String title;

    @NotNull(message = "본문을 비워둘수 없습니다.")
    @Size(max = 1000, message = "본문은 1000자를 넘길 수 없습니다.")
    private String content;

    @NotBlank(message = "이름을 비워둘수 없습니다.")
    private String userName;
}
```

이렇게 에러 메시지를 1차원적으로 표현했다면

```java
package com.example.boardcrud.exception;

public class NoWordException extends RuntimeException {
    public NoWordException(String feild, String noWord) {
        super(feild + "에 금지어 " + noWord + "이(가) 포함되어있습니다.");
    }
}
```

이렇게 에러 메시지 조차 커스텀 해서 조금 더 친절하게 표현할 수 있다.

---

그럼 동작하는지 알아보자

![스크린샷 2025-08-06 오후 1.05.53.png](attachment:dff580a5-013d-4de8-8a64-ed2b89b8406d:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.05.53.png)

이렇게 각 에러에 맞는 클래스를 만들어서 그 에러에 맞게 에러 메시지를 표현하는 방식을 정의한다.

그리고 나서 그 에러를 판단하는 로직을 service에 구현한다.

그럼 CreateService는 이렇게 된다.

```java
package com.example.boardcrud.Service;

import com.example.boardcrud.Entity.Post;
import com.example.boardcrud.Repository.PostRepository;
import com.example.boardcrud.dto.Request.PostRequest;
import com.example.boardcrud.exception.NoWordException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class CreateService {
    private final PostRepository postRepository;

    public void createPost(PostRequest postRequest) {
        String title = postRequest.getTitle();
        String content = postRequest.getContent();

        List<String> noWord = List.of("개병신", "씨발", "장애인", "엄마", "아빠"); // 여기서 금지어 목록을 정한다.

        for(String word : noWord) { // 여기서 word에 noWord에 있는 단어를 한단어씩 넣어가면서 반복한다.
            if(title.contains(word)) { // 여기서 contains를 통해 word에 금지어가 포함되어있는지 확인한다.
                throw new NoWordException("제목", word); // 만약에 있다면 NoWordException생성자를 호출한다.
            }
        }

        for(String word : noWord) {
            if(content.contains(word)) {
                throw new NoWordException("본문", word);
            }
        }

        Post post = new Post(
                postRequest.getTitle(),
                postRequest.getContent(),
                postRequest.getUserName()
        );

        postRepository.save(post);
    }

}
```

그리고 다음과 같은 코드로 마지막엔 GlobalExceptionHandler에 따로 마감을 해줘야 동작한다.

```java
package com.example.boardcrud.exception;

import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.List;
import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<List<String>> handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        List<String> errors = e.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(FieldError::getDefaultMessage)
                .collect(Collectors.toList());
        return ResponseEntity.badRequest().body(errors);
    }

    @ExceptionHandler(NoWordException.class) // 요렇게 말이죠
    public ResponseEntity<String> handleNoWordException(NoWordException e) {
        return ResponseEntity.badRequest().body(e.getMessage());
    }
}
```

---